{"version":3,"sources":["components/Controls/Controls.module.css","components/UI/Button.module.css","components/store/mazeGenerator.js","components/store/gridContext.js","components/store/controlContext.js","components/Grid/Cell.js","components/Grid/Row.js","components/Grid/Grid.js","components/UI/Button.js","components/Controls/Controls.js","App.js","components/Algorithms/AStar.js","components/Algorithms/Dijkstra.js","components/Controls/SelectedAlgorithm.js","index.js"],"names":["module","exports","mazeGenerator","GRID_ROWS","GRID_COLS","pathingOrder","inList","nodeToCheck","nodeSet","operation","node","createDefaultGrid","defaultGrid","y","grid_row","x","push","findOptions","currentNode","currentNodes","options","up","down","left","right","grid","isoNodes","nodesPath","nodeNetwork","splice","Math","floor","random","length","newNode","nextNode","filter","clearedY","clearedX","startingNode","GridContext","React","createContext","undefined","setGrid","plotPoint","setPlotPoint","plotLine","resetGridContext","createMaze","GridProvider","props","useState","setPathingOrder","shrtstDis","Infinity","bubbled","class","vertex","prevVertex","gCost","hCost","this","useEffect","console","log","setTimeout","nodes","newNodes","shift","prevGrid","newGrid","Provider","value","children","ControlContext","control","setControl","startEnd","setStartEnd","mouseDown","setMouseDown","controlButtonClick","overCell","addStartEnd","removeStartEnd","resetControl","algorithm","setAlgorithm","ControlProvider","useContext","start","end","prevValue","toString","setting","cell","firstSquare","Cell","mark","className","onMouseEnter","onMouseDown","onMouseUp","Row","row","map","id","Grid","Button","buttonClass","name","classes","selected","button","onClick","Controls","hover","setHover","handleClick","e","target","selectAlgorithm","controls","onMouseOver","onMouseLeave","dropdownbtn","App","AStarAlgorithm","unvisited","setUnvisited","aStar","prevUnvisited","newUnvisited","sort","a","b","fCost","checkNeighbourCell","neighbourY","neighbourX","defaultUnvisited","abs","createUnvisited","Fragment","DijkstraAlgorithm","dijkstra","SelectedAlgorithm","wrapper","Dijkstra","AStar","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.dfb820db.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"controls\":\"Controls_controls__2qNYd\",\"dropdown-container\":\"Controls_dropdown-container__1tfk2\",\"dropdownbtn\":\"Controls_dropdownbtn__3nCor\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button_button__3uJNj\",\"selected\":\"Button_selected__1Mo_h\"};","function mazeGenerator(GRID_ROWS, GRID_COLS) {\r\n\tlet pathingOrder = [];\r\n\t//check of overlap\r\n\tfunction inList(nodeToCheck, nodeSet, operation) {\r\n\t\tfor (let node of nodeSet) {\r\n\t\t\t// console.log(operation, nodeSet);\r\n\t\t\tif (nodeToCheck[0] === node[0] && nodeToCheck[1] === node[1]) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction createDefaultGrid() {\r\n\t\tconst defaultGrid = [];\r\n\r\n\t\tfor (let y = 0; y < GRID_ROWS; y++) {\r\n\t\t\tconst grid_row = [];\r\n\t\t\tfor (let x = 0; x < GRID_COLS; x++) {\r\n\t\t\t\tif (y % 2 === 1) {\r\n\t\t\t\t\tgrid_row.push(1);\r\n\t\t\t\t} else if (x % 2 === 1) {\r\n\t\t\t\t\tgrid_row.push(1);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tgrid_row.push(0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdefaultGrid.push(grid_row);\r\n\t\t}\r\n\t\treturn defaultGrid;\r\n\t}\r\n\r\n\t//check options for up, down, left & right\r\n\tfunction findOptions(currentNode, currentNodes) {\r\n\t\tconst options = [];\r\n\t\tconst up = [ currentNode[0] - 2, currentNode[1] ];\r\n\t\tif (!inList(up, currentNodes, 'find options') && up[0] >= 0) {\r\n\t\t\toptions.push(up);\r\n\t\t}\r\n\t\tconst down = [ currentNode[0] + 2, currentNode[1] ];\r\n\t\tif (!inList(down, currentNodes, 'find options') && down[0] < GRID_ROWS) {\r\n\t\t\toptions.push(down);\r\n\t\t}\r\n\t\tconst left = [ currentNode[0], currentNode[1] - 2 ];\r\n\t\tif (!inList(left, currentNodes, 'find options') && left[1] >= 0) {\r\n\t\t\toptions.push(left);\r\n\t\t}\r\n\t\tconst right = [ currentNode[0], currentNode[1] + 2 ];\r\n\t\tif (!inList(right, currentNodes, 'find options') && right[1] < GRID_COLS) {\r\n\t\t\toptions.push(right);\r\n\t\t}\r\n\t\treturn options;\r\n\t}\r\n\r\n\tconst grid = createDefaultGrid();\r\n\r\n\t// All AVAILABLE NODES\r\n\tlet isoNodes = [];\r\n\tfor (let y = 0; y < GRID_ROWS; y++) {\r\n\t\tfor (let x = 0; x < GRID_COLS; x++) {\r\n\t\t\tif (grid[y][x] === 0) {\r\n\t\t\t\tisoNodes.push([ y, x ]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// START CONNECTED NODE NETWORK (list)\r\n\tlet nodeNetwork = isoNodes.splice(Math.floor(Math.random()* isoNodes.length), 1); //TODO will make this random\r\n\r\n\tlet nodesPath;\r\n\r\n\t//while isolated node remain\r\n\twhile (isoNodes.length > 0) {\r\n\t\tnodesPath = [];\r\n\r\n\t\t//randomly pick an available node & put it in nodesPath & also remove it from isolated nodes\r\n\t\tlet newNode = isoNodes.splice(Math.floor(Math.random() * isoNodes.length), 1)[0];\r\n\t\tnodesPath.push(newNode);\r\n\r\n\t\t// console.log('\\nstartingNode', newNode);\r\n\r\n\t\twhile (true) {\r\n\t\t\tlet nextNode = [];\r\n\t\t\tlet options = [];\r\n\r\n\t\t\t// check available nodes (what's 1 - physically possible & 2 - not overlapping current path)\r\n\t\t\toptions = findOptions(newNode, nodesPath);\r\n\r\n\t\t\t// if there is a loop in path, pick new node inside loop instead\r\n\t\t\twhile (options.length === 0) {\r\n\t\t\t\tnewNode = nodesPath[Math.floor(Math.random() * nodesPath.length)];\r\n\t\t\t\tnodesPath.push(newNode);\r\n\t\t\t\toptions = findOptions(newNode, nodesPath);\r\n\t\t\t}\r\n\r\n\t\t\t//pick direction\r\n\t\t\tnextNode = options[Math.floor(Math.random() * options.length)];\r\n\t\t\tisoNodes = isoNodes.filter((node) => {\r\n\t\t\t\tif (node[0] === nextNode[0] && node[1] === nextNode[1]) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\r\n\t\t\t// Exit loop when connection found (check if next node is a Network node)\r\n\t\t\tlet clearedY = (newNode[0] + nextNode[0]) / 2;\r\n\t\t\tlet clearedX = (newNode[1] + nextNode[1]) / 2;\r\n\t\t\tif (inList(nextNode, nodeNetwork, 'check if connected')) {\r\n\t\t\t\tpathingOrder = [ ...pathingOrder, [ clearedY, clearedX ] ];\r\n\r\n\t\t\t\tgrid[clearedY][clearedX] = 0;\r\n\r\n\t\t\t\t// console.log('-------------- nodesPath', nodesPath);\r\n\t\t\t\t// for (let row of grid) {\r\n\t\t\t\t// \tconsole.log(row);\r\n\t\t\t\t// }\r\n\r\n\t\t\t\tnodeNetwork = [ ...nodeNetwork, ...nodesPath ];\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tpathingOrder = [ ...pathingOrder, [ clearedY, clearedX ] ];\r\n\r\n                nodesPath.push(nextNode);\r\n                \r\n\t\t\t\tgrid[clearedY][clearedX] = 0;\r\n\t\t\t\tnewNode = nextNode;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// console.log(pathingOrder);\r\n\r\n\treturn { grid, pathingOrder, defaultGrid: createDefaultGrid(), startingNode: nodeNetwork[0] };\r\n}\r\n\r\nexport default mazeGenerator;\r\n","import React, { useState, useEffect } from 'react';\r\nimport mazeGenerator from './mazeGenerator';\r\n\r\nconst GridContext = React.createContext({\r\n\tGRID_ROWS: undefined,\r\n\tGRID_COLS: undefined,\r\n\tgrid: [],\r\n\tsetGrid: () => {},\r\n\tplotPoint: undefined,\r\n\tsetPlotPoint: () => {},\r\n\tplotLine: () => {},\r\n\tresetGridContext: () => {},\r\n\tcreateMaze: () => {}\r\n});\r\n\r\nexport const GridProvider = (props) => {\r\n\t//! for the MAZE, ODD numbers look better\r\n\tconst GRID_ROWS = 21;\r\n\tconst GRID_COLS = 21;\r\n\r\n\tconst [ grid, setGrid ] = useState(createDefaultGrid());\r\n\tconst [ plotPoint, setPlotPoint ] = useState({ y: null, x: null });\r\n\tconst [ pathingOrder, setPathingOrder ] = useState([]);\r\n\r\n\tfunction plotLine() {\r\n\t\t// Stop when end-node hit\r\n\t\tif (grid[plotPoint.y][plotPoint.x].class === 'start-end-node') {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsetGrid((prevGrid) => {\r\n\t\t\tlet newGrid = [ ...prevGrid ];\r\n\r\n\t\t\tnewGrid[plotPoint.y][plotPoint.x].class = 'path';\r\n\t\t\tsetPlotPoint(newGrid[plotPoint.y][plotPoint.x].prevVertex);\r\n\r\n\t\t\treturn newGrid;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction createDefaultGrid() {\r\n\t\tconst defaultGrid = [];\r\n\r\n\t\tfor (let y = 0; y < GRID_ROWS; y++) {\r\n\t\t\tconst grid_row = [];\r\n\t\t\tfor (let x = 0; x < GRID_COLS; x++) {\r\n\t\t\t\tgrid_row.push({\r\n\t\t\t\t\tshrtstDis: Infinity,\r\n\t\t\t\t\tx: x,\r\n\t\t\t\t\ty: y,\r\n\t\t\t\t\tbubbled: false,\r\n\t\t\t\t\tclass: '',\r\n\t\t\t\t\tvertex: [ y, x ],\r\n\t\t\t\t\tprevVertex: { y: null, x: null },\r\n\t\t\t\t\tgCost: Infinity, // Distance to Start node\r\n\t\t\t\t\thCost: Infinity, // Distance to End node\r\n\t\t\t\t\tget fCost() {\r\n\t\t\t\t\t\treturn this.gCost + this.hCost;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tdefaultGrid.push(grid_row);\r\n\t\t}\r\n\t\treturn defaultGrid;\r\n\t}\r\n\r\n\tfunction resetGridContext() {\r\n\t\tsetGrid(createDefaultGrid());\r\n\t\tsetPlotPoint({ y: null, x: null });\r\n\t}\r\n\r\n\tuseEffect(\r\n\t\t() => {\r\n\t\t\tif (pathingOrder.length > 0) {\r\n\t\t\t\tconsole.log('here');\r\n\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\tsetPathingOrder((nodes) => {\r\n\t\t\t\t\t\tconst newNodes = [ ...nodes ];\r\n\t\t\t\t\t\tconst node = newNodes.shift();\r\n\t\t\t\t\t\tsetGrid((prevGrid) => {\r\n\t\t\t\t\t\t\tconst newGrid = [ ...prevGrid ];\r\n\t\t\t\t\t\t\tnewGrid[node[0]][node[1]].class = '';\r\n\t\t\t\t\t\t\treturn newGrid;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\treturn newNodes;\r\n\t\t\t\t\t});\r\n\t\t\t\t}, 10);\r\n\t\t\t}\r\n\t\t},\r\n\t\t[ pathingOrder, setPathingOrder, setGrid ]\r\n\t);\r\n\r\n\tfunction createMaze() {\r\n        const { pathingOrder, defaultGrid /*grid: maze, startingNode*/ } = mazeGenerator(GRID_ROWS, GRID_COLS);\r\n\r\n\t\tsetPathingOrder(pathingOrder);\r\n\r\n\t\tsetGrid(() => {\r\n\t\t\tconst newGrid = createDefaultGrid();\r\n\t\t\tfor (let y = 0; y < GRID_ROWS; y++) {\r\n\t\t\t\tfor (let x = 0; x < GRID_COLS; x++) {\r\n\t\t\t\t\tif (defaultGrid[y][x] === 1) {\r\n\t\t\t\t\t\tnewGrid[y][x].class = 'block';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn newGrid;\r\n\t\t});\r\n\t}\r\n\r\n\treturn (\r\n\t\t<GridContext.Provider\r\n\t\t\tvalue={{\r\n\t\t\t\tGRID_ROWS,\r\n\t\t\t\tGRID_COLS,\r\n\t\t\t\tgrid,\r\n\t\t\t\tsetGrid,\r\n\t\t\t\tplotPoint,\r\n\t\t\t\tsetPlotPoint,\r\n\t\t\t\tplotLine,\r\n\t\t\t\tresetGridContext: resetGridContext,\r\n\t\t\t\tcreateMaze\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{props.children}\r\n\t\t</GridContext.Provider>\r\n\t);\r\n};\r\n\r\nexport default GridContext;\r\n","import React, { useState, useContext } from 'react';\r\nimport GridContext from './gridContext';\r\n\r\nconst ControlContext = React.createContext({\r\n\tcontrol: undefined,\r\n\tsetControl: () => {},\r\n\tstartEnd: undefined,\r\n\tsetStartEnd: () => {},\r\n\tmouseDown: undefined,\r\n\tsetMouseDown: () => {},\r\n\tcontrolButtonClick: () => {},\r\n\toverCell: () => {},\r\n\taddStartEnd: () => {},\r\n\tremoveStartEnd: () => {},\r\n\tresetControl: () => {},\r\n\talgorithm: undefined,\r\n\tsetAlgorithm: () => {}\r\n});\r\n\r\nexport const ControlProvider = (props) => {\r\n\tconst { setGrid } = useContext(GridContext);\r\n\r\n\tconst [ control, setControl ] = useState('start-end-node');\r\n\tconst [ mouseDown, setMouseDown ] = useState(false);\r\n\tconst [ startEnd, setStartEnd ] = useState({ start: [], end: [] });\r\n\tconst [ algorithm, setAlgorithm ] = useState('aStar');\r\n\r\n\tfunction controlButtonClick(setting) {\r\n\t\tsetControl(setting);\r\n\t}\r\n\r\n    /** allows for mouse drag & draw (especially for 'Block's) */\r\n\tfunction overCell(cell, firstSquare) {\r\n\t\t// console.log('OverCell', mouseDown); //! the setMouseDown function is delayed so we're adding an extra parameter (firstSquare)\r\n\t\tif (firstSquare || mouseDown) {\r\n\t\t\tconst y = cell.y;\r\n\t\t\tconst x = cell.x;\r\n\r\n\t\t\t// console.log(`${y}, ${x}`);\r\n\t\t\tsetGrid((prevGrid) => {\r\n\t\t\t\tconst newGrid = [ ...prevGrid ];\r\n\r\n\t\t\t\tif (prevGrid[y][x].class === control) {\r\n\t\t\t\t\t// remove class\r\n\r\n\t\t\t\t\tif (control === 'start-end-node') {\r\n\t\t\t\t\t\tremoveStartEnd(y, x);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewGrid[y][x].class = '';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// add class\r\n\r\n\t\t\t\t\tif (prevGrid[y][x].class === 'start-end-node') {\r\n\t\t\t\t\t\tremoveStartEnd(y, x);\r\n\t\t\t\t\t} else if (control === 'start-end-node') {\r\n\t\t\t\t\t\taddStartEnd(newGrid, y, x);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewGrid[y][x].class = control;\r\n\t\t\t\t}\r\n\t\t\t\treturn newGrid;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addStartEnd(newGrid, y, x) {\r\n\t\tsetStartEnd((prevValue) => {\r\n\t\t\tif (prevValue.start.length === 0) {\r\n\t\t\t\t//! if start is empty, fill start\r\n\t\t\t\treturn { ...prevValue, start: [ y, x ] };\r\n\t\t\t} else {\r\n\t\t\t\t//! else fill end\r\n\t\t\t\tif (prevValue.end.length !== 0) {\r\n\t\t\t\t\t//! if end has value, erase class from this node in the grid\r\n\t\t\t\t\tnewGrid[prevValue.end[0]][prevValue.end[1]].class = '';\r\n\t\t\t\t}\r\n\t\t\t\treturn { ...prevValue, end: [ y, x ] };\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tfunction removeStartEnd(y, x) {\r\n\t\tif (startEnd.end.toString() === [ y, x ].toString()) {\r\n\t\t\tsetStartEnd((prevValue) => {\r\n\t\t\t\treturn { ...prevValue, end: [] };\r\n\t\t\t});\r\n\t\t} else if (startEnd.start.toString() === [ y, x ].toString()) {\r\n\t\t\tsetStartEnd((prevValue) => {\r\n\t\t\t\treturn { start: prevValue.end, end: [] };\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction resetControl() {\r\n\t\tsetControl('start-end-node');\r\n\t\tsetMouseDown(false);\r\n\t\tsetStartEnd({ start: [], end: [] });\r\n\t}\r\n\r\n\treturn (\r\n\t\t<ControlContext.Provider\r\n\t\t\tvalue={{\r\n\t\t\t\tcontrol,\r\n\t\t\t\tsetControl,\r\n\t\t\t\tstartEnd,\r\n\t\t\t\tsetStartEnd,\r\n\t\t\t\tmouseDown,\r\n\t\t\t\tsetMouseDown,\r\n\t\t\t\tcontrolButtonClick,\r\n\t\t\t\toverCell,\r\n\t\t\t\taddStartEnd,\r\n\t\t\t\tremoveStartEnd,\r\n\t\t\t\tresetControl,\r\n\t\t\t\talgorithm,\r\n\t\t\t\tsetAlgorithm\r\n\t\t\t}}\r\n\t\t>\r\n\t\t\t{props.children}\r\n\t\t</ControlContext.Provider>\r\n\t);\r\n};\r\n\r\nexport default ControlContext;\r\n","// import {useState} from 'react'\r\nimport './Cell.css';\r\nimport ControlContext from '../store/controlContext';\r\nimport { useContext } from 'react';\r\n\r\nfunction Cell(props) {\r\n    const { overCell, setMouseDown, startEnd } = useContext(ControlContext)\r\n    \r\n    /** icons for the start & end nodes */\r\n    let mark = ''\r\n    if (props.cell.y === startEnd.start[0] && props.cell.x === startEnd.start[1]) {\r\n        mark = <i className=\"fas fa-star\"></i>\r\n    } else if (props.cell.y === startEnd.end[0] && props.cell.x === startEnd.end[1]) {\r\n        mark = <i className=\"fas fa-flag\"></i>\r\n    } else if (props.cell.class === 'path') {\r\n        // mark = <p>*</p>\r\n    }\r\n\r\n\treturn (\r\n\t\t<div\r\n\t\t\tonMouseEnter={() => overCell(props.cell)}\r\n\t\t\tclassName=\"cell\"\r\n\t\t\tonMouseDown={() => {\r\n\t\t\t\tsetMouseDown(true);\r\n\t\t\t\toverCell(props.cell, true);\r\n\t\t\t}}\r\n\t\t\tonMouseUp={() => setMouseDown(false)}\r\n\t\t>\r\n            <div className={`inside ${props.cell.class}`}>{mark }</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Cell;\r\n","import Cell from './Cell';\r\nimport './Row.css'\r\n\r\nfunction Row(props) {\r\n\r\n\treturn (\r\n\t\t<div className='row'>\r\n            {props.row.map((cell) => {\r\n                return <Cell key={cell.x} id={cell.x} cell={cell}/>;\r\n\t\t\t})}\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Row;\r\n","import Row from './Row';\r\nimport './Grid.css';\r\n\r\nfunction Grid(props) {\r\n\r\n\treturn (\r\n        <div className=\"grid\">\r\n            {props.grid.map((row) => {\r\n                return <Row key={row[0].y} id={row[0].y} row={row}/>;\r\n\t\t\t})}\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Grid;\r\n","import classes from './Button.module.css';\r\nimport { useContext } from 'react'\r\nimport ControlContext from '../store/controlContext';\r\n\r\nfunction Button(props) {\r\n    const { control } = useContext(ControlContext)\r\n    const buttonClass = control === props.name ? classes.selected : ''\r\n\treturn (\r\n        <button className={`${classes.button} ${buttonClass}`} onClick={props.onClick} name={props.name}>\r\n\t\t\t{props.children}\r\n\t\t</button>\r\n\t);\r\n}\r\n\r\nexport default Button;\r\n","import classes from './Controls.module.css';\r\nimport Button from '../UI/Button';\r\nimport ControlContext from '../store/controlContext';\r\nimport React, { useContext, useState } from 'react';\r\nimport GridContext from '../store/gridContext';\r\n\r\nfunction Controls() {\r\n\tconst { controlButtonClick, resetControl, algorithm, setAlgorithm, setControl } = useContext(ControlContext);\r\n\tconst { resetGridContext, createMaze } = useContext(GridContext);\r\n\tconst [ hover, setHover ] = useState(false);\r\n\r\n\tfunction handleClick(e) {\r\n\t\tif (e.target.name === 'reset') {\r\n\t\t\tresetControl();\r\n\t\t\tresetGridContext();\r\n        } else if (e.target.name === 'maze') {\r\n            resetControl();\r\n\t\t\tcreateMaze();\r\n\t\t} else {\r\n\t\t\tcontrolButtonClick(e.target.name);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mouseOverDropdown() {\r\n\t\tsetHover(true);\r\n\t}\r\n\r\n\tfunction mouseOffDropdown() {\r\n\t\tsetHover(false);\r\n\t}\r\n\r\n\tfunction selectAlgorithm(algorithm) {\r\n\t\tsetAlgorithm(algorithm);\r\n\t\tsetHover(false);\r\n\t}\r\n\r\n\treturn (\r\n\t\t<div className={classes.controls}>\r\n\t\t\t<Button onClick={handleClick} name=\"start-end-node\">\r\n\t\t\t\tStart/End\r\n\t\t\t</Button>\r\n\t\t\t<Button onClick={handleClick} name=\"solve\">\r\n\t\t\t\tSolve\r\n\t\t\t</Button>\r\n\t\t\t<Button onClick={handleClick} name=\"reset\">\r\n\t\t\t\tReset\r\n\t\t\t</Button>\r\n\t\t\t<Button onClick={handleClick} name=\"block\">\r\n\t\t\t\tBlock\r\n\t\t\t</Button>\r\n\t\t\t<Button onClick={handleClick} name=\"maze\">\r\n\t\t\t\tCreate Maze\r\n\t\t\t</Button>\r\n\t\t\t<div onMouseOver={mouseOverDropdown} onMouseLeave={mouseOffDropdown}>\r\n\t\t\t\t<div className={classes['dropdown-container']}>\r\n\t\t\t\t\t{(algorithm === 'dijkstra' || hover) && (\r\n\t\t\t\t\t\t<Button onClick={() => selectAlgorithm('dijkstra')} className={classes.dropdownbtn}>\r\n\t\t\t\t\t\t\tDijkstra\r\n\t\t\t\t\t\t</Button>\r\n\t\t\t\t\t)}\r\n\t\t\t\t\t{(algorithm === 'aStar' || hover) && (\r\n\t\t\t\t\t\t<Button onClick={() => selectAlgorithm('aStar')} className={classes.dropdownbtn}>\r\n\t\t\t\t\t\t\tA*\r\n\t\t\t\t\t\t</Button>\r\n\t\t\t\t\t)}\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Controls;\r\n","/**\r\n **Project Console: \r\n * https://console.firebase.google.com/project/path-finder-90df8/overview\r\n * \r\n **Hosting URL: \r\n * https://path-finder-90df8.web.app\r\n */\r\n\r\nimport { useEffect, useContext } from 'react';\r\nimport './App.css';\r\n\r\n//* Components\r\nimport Grid from './components/Grid/Grid';\r\nimport Controls from './components/Controls/Controls';\r\n\r\n//* useContext\r\nimport GridContext from './components/store/gridContext';\r\nimport ControlContext from './components/store/controlContext';\r\n\r\nfunction App() {\r\n\tconst { grid, plotLine } = useContext(GridContext);\r\n\tconst { control } = useContext(ControlContext);\r\n\r\n\tuseEffect(\r\n\t\t() => {\r\n\t\t\tif (control === 'plotLine') {\r\n\t\t\t\tsetTimeout(plotLine, 20);\r\n\t\t\t}\r\n\t\t},\r\n\t\t[ control, plotLine ]\r\n\t);\r\n\r\n\treturn (\r\n\t\t<div className=\"app\">\r\n\t\t\t<h1>Path Finder</h1>\r\n\t\t\t<Controls />\r\n\t\t\t<Grid grid={grid} />\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default App;\r\n","/** This code is built on top of Dijkstra with just a few modifications */\r\n\r\nimport React, { useState, useContext, useEffect } from 'react';\r\nimport GridContext from '../store/gridContext';\r\nimport ControlContext from '../store/controlContext';\r\n\r\nconst AStarAlgorithm = (props) => {\r\n\tconst { grid, setGrid, GRID_ROWS, GRID_COLS, setPlotPoint } = useContext(GridContext);\r\n\tconst { control, setControl, startEnd } = useContext(ControlContext);\r\n\r\n\tconst [ unvisited, setUnvisited ] = useState(null);\r\n\r\n\tfunction createUnvisited() {\r\n\t\tconst defaultUnvisited = [];\r\n\r\n\t\t/**gCost is distance to start, \r\n         * hCost is distance to end \r\n         * fCost is gCost + hCost*/\r\n\r\n\t\tfor (let y of grid) {\r\n\t\t\tfor (let cell of y) {\r\n\t\t\t\tcell.gCost = Infinity;\r\n\t\t\t\tcell.hCost = Math.abs(startEnd.end[0] - cell.y) + Math.abs(startEnd.end[1] - cell.x);\r\n\r\n\t\t\t\tif (cell.class === '' || cell.class === 'start-end-node') {\r\n\t\t\t\t\t// give the starting node a gCost of zero\r\n\t\t\t\t\tif (cell.vertex.toString() === startEnd.start.toString()) {\r\n\t\t\t\t\t\tcell.gCost = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdefaultUnvisited.push(cell);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn defaultUnvisited;\r\n\t}\r\n\r\n\tconst aStar = () => {\r\n\t\tsetUnvisited((prevUnvisited) => {\r\n\t\t\tconst newUnvisited = [\r\n\t\t\t\t...prevUnvisited.sort((a, b) => (a.fCost > b.fCost ? 1 : b.fCost > a.fCost ? -1 : 0))\r\n\t\t\t];\r\n\t\t\tlet [ y, x ] = newUnvisited[0].vertex;\r\n\r\n\t\t\tsetGrid((prevGrid) => {\r\n\t\t\t\tlet newGrid = [ ...prevGrid ];\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y - 1, x);\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y + 1, x);\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y, x - 1);\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y, x + 1);\r\n\r\n\t\t\t\tif (newGrid[y][x].class === '') {\r\n\t\t\t\t\tnewGrid[y][x].class = 'visited';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (y === startEnd.end[0] && x === startEnd.end[1]) {\r\n\t\t\t\t\tsetControl('plotLine');\r\n\t\t\t\t\tsetPlotPoint({ ...newGrid[y][x].prevVertex });\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn newGrid;\r\n\t\t\t});\r\n\r\n\t\t\tnewUnvisited.shift();\r\n\t\t\treturn newUnvisited;\r\n\t\t});\r\n\t};\r\n\r\n\tfunction checkNeighbourCell(newGrid, y, x, neighbourY, neighbourX) {\r\n\t\t// If beyond grid limits, pass\r\n\t\tif (neighbourY < 0 || neighbourY >= GRID_ROWS || neighbourX < 0 || neighbourX >= GRID_COLS) {\r\n\t\t\treturn newGrid;\r\n\t\t}\r\n\r\n\t\tif (newGrid[y][x].gCost + 1 < newGrid[neighbourY][neighbourX].gCost) {\r\n\t\t\tnewGrid[neighbourY][neighbourX].gCost = grid[y][x].gCost + 1;\r\n\t\t\tnewGrid[neighbourY][neighbourX].prevVertex = { y: y, x: x };\r\n\t\t\treturn newGrid;\r\n\t\t}\r\n\t\treturn newGrid;\r\n\t}\r\n\r\n\tuseEffect(\r\n\t\t() => {\r\n\t\t\tif (control === 'solve') {\r\n\t\t\t\tif (unvisited === null) setUnvisited(createUnvisited());\r\n\t\t\t\telse if (unvisited.length === 0) return;\r\n\t\t\t\telse {\r\n\t\t\t\t\tsetTimeout(aStar, 20);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (control === 'start-end-node') {\r\n\t\t\t\tsetUnvisited(null);\r\n\t\t\t}\r\n\t\t},\r\n\t\t[ control, unvisited ]\r\n\t);\r\n\r\n\treturn <React.Fragment>{props.children}</React.Fragment>;\r\n};\r\n\r\n/**This Component is fully contained & simply needs to be used as a wrapper to function (I've wrapped it in index.js under 'SelectedAlgorithm' component) */\r\nexport default AStarAlgorithm;\r\n","import React, { useState, useContext, useEffect } from 'react';\r\nimport GridContext from '../store/gridContext';\r\nimport ControlContext from '../store/controlContext';\r\n\r\nconst DijkstraAlgorithm = (props) => {\r\n\tconst { grid, setGrid, GRID_ROWS, GRID_COLS, setPlotPoint } = useContext(GridContext);\r\n\tconst { control, setControl, startEnd } = useContext(ControlContext);\r\n\r\n\tconst [ unvisited, setUnvisited ] = useState(null);\r\n\t// const [ visited, setVisited ] = useState([]);\r\n\r\n\tfunction createUnvisited() {\r\n\t\tconst defaultUnvisited = [];\r\n\r\n\t\tfor (let y of grid) {\r\n\t\t\tfor (let cell of y) {\r\n\t\t\t\tif (cell.class === '' || cell.class === 'start-end-node') {\r\n                    if (cell.vertex.toString() === startEnd.start.toString()) {\r\n                         // starting node gets a shortest distance of zero\r\n\t\t\t\t\t\tcell.shrtstDis = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdefaultUnvisited.push(cell);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn defaultUnvisited;\r\n\t}\r\n\r\n\tfunction dijkstra() {\r\n\t\tsetUnvisited((prevUnvisited) => {\r\n\t\t\tconst newUnvisited = [\r\n\t\t\t\t...prevUnvisited.sort((a, b) => (a.shrtstDis > b.shrtstDis ? 1 : b.shrtstDis > a.shrtstDis ? -1 : 0))\r\n\t\t\t];\r\n\t\t\tlet [ y, x ] = newUnvisited[0].vertex;\r\n\r\n\t\t\tsetGrid((prevGrid) => {\r\n\t\t\t\tlet newGrid = [ ...prevGrid ];\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y - 1, x);\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y + 1, x);\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y, x - 1);\r\n\t\t\t\tnewGrid = checkNeighbourCell(newGrid, y, x, y, x + 1);\r\n\r\n\t\t\t\tif (newGrid[y][x].class === '') {\r\n\t\t\t\t\tnewGrid[y][x].class = 'visited';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (y === startEnd.end[0] && x === startEnd.end[1]) {\r\n\t\t\t\t\tsetControl('plotLine');\r\n\t\t\t\t\tsetPlotPoint({ ...newGrid[y][x].prevVertex });\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn newGrid;\r\n\t\t\t});\r\n\r\n\t\t\t// setVisited((prevValue) => {\r\n\t\t\t// \treturn [ ...prevValue, newUnvisited[0] ];\r\n\t\t\t// });\r\n\r\n\t\t\tnewUnvisited.shift();\r\n\t\t\treturn newUnvisited;\r\n\t\t});\r\n\t}\r\n\r\n\tfunction checkNeighbourCell(newGrid, y, x, neighbourY, neighbourX) {\r\n\t\t// If beyond grid limits, pass\r\n\t\tif (neighbourY < 0 || neighbourY >= GRID_ROWS || neighbourX < 0 || neighbourX >= GRID_COLS) {\r\n\t\t\treturn newGrid;\r\n\t\t}\r\n\r\n\t\tif (newGrid[y][x].shrtstDis + 1 < newGrid[neighbourY][neighbourX].shrtstDis) {\r\n\t\t\tnewGrid[neighbourY][neighbourX].shrtstDis = grid[y][x].shrtstDis + 1;\r\n\t\t\tnewGrid[neighbourY][neighbourX].prevVertex = { y: y, x: x };\r\n\t\t\treturn newGrid;\r\n\t\t}\r\n\t\treturn newGrid;\r\n\t}\r\n\r\n\tuseEffect(\r\n\t\t() => {\r\n\t\t\tconsole.log(control);\r\n\t\t\tif (control === 'solve') {\r\n\t\t\t\tif (unvisited === null) setUnvisited(createUnvisited());\r\n\t\t\t\telse if (unvisited.length === 0) return;\r\n\t\t\t\telse {\r\n\t\t\t\t\tsetTimeout(dijkstra, 20);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (control === 'start-end-node') {\r\n\t\t\t\tsetUnvisited(null);\r\n\t\t\t}\r\n\t\t},\r\n\t\t[ control, unvisited ]\r\n\t);\r\n\r\n\treturn <React.Fragment>{props.children}</React.Fragment>;\r\n};\r\n\r\n/**This Component is fully contained & simply needs to be used as a wrapper to function (I've wrapped it in index.js under 'SelectedAlgorithm' component) */\r\nexport default DijkstraAlgorithm;\r\n","import AStarAlgorithm from '../Algorithms/AStar';\r\nimport DijkstraAlgorithm from '../Algorithms/Dijkstra';\r\nimport React, { useContext } from 'react';\r\nimport ControlContext from '../store/controlContext';\r\n\r\n/** Applies whatever Algorithm is selected by the useState 'control' variable*/\r\nexport const SelectedAlgorithm = (props) => {\r\n\tconst { algorithm } = useContext(ControlContext);\r\n\r\n\tlet wrapper = undefined;\r\n\tif (algorithm === 'dijkstra') wrapper = <DijkstraAlgorithm>{props.children}</DijkstraAlgorithm>;\r\n\telse if (algorithm === 'aStar') wrapper = <AStarAlgorithm>{props.children}</AStarAlgorithm>;\r\n\r\n\treturn <React.Fragment>{wrapper}</React.Fragment>;\r\n};\r\n\r\nexport default SelectedAlgorithm;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { GridProvider } from './components/store/gridContext';\r\nimport { ControlProvider } from './components/store/controlContext';\r\nimport SelectedAlgorithm from './components/Controls/SelectedAlgorithm'\r\n\r\nReactDOM.render(\r\n\t<GridProvider>\r\n\t\t<ControlProvider>\r\n\t\t\t<SelectedAlgorithm>\r\n\t\t\t\t<App />\r\n\t\t\t</SelectedAlgorithm>\r\n\t\t</ControlProvider>\r\n\t</GridProvider>,\r\n\tdocument.getElementById('root')\r\n);\r\n"],"sourceRoot":""}